<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepAD AI 분석 서비스</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f5;
        }
        #send-btn {
            background-color: #019af9;
            color: #fff;
        }
        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 1.5rem;
            word-wrap: break-word;
            line-height: 1.6;
        }
        .user-message {
            background-color: #019af9;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 0.5rem;
            scroll-margin-top: 20px;
        }
        .ai-text-response {
            max-width: 100%;
            padding: 1rem;
            background-color: #fbfbfb;
            color: #212121;
            align-self: flex-start;
            word-wrap: break-word;
            line-height: 1.6;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            animation: fadeIn 2s ease-in-out;
        }
        .ai-text-response .final_response { opacity: 0; }
        .thinking-process-container {
            max-height: 3rem; /* 축소된 높이 */
            transition: max-height 0.5s ease-out;
            overflow: hidden;
            background-color: #f9f9f9;
        }
        .thinking-process-container.expanded {
            max-height: 100%; /* 확장된 높이 */
            height: auto;
        }
        .thinking-content {
            display: none;
            padding: 0 1.5rem 1rem;
            font-style: italic;
            font-size: 14px;
           animation: fadeIn 1s ease-in-out;
        }
        .thinking-content p:last-child {
            animation: fadeIn 1s ease-in-out;
        }
        .thinking-process-container.expanded .thinking-content {
            display: block;
        }
        /* 로딩 스피너 애니메이션 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        .fade-in-effect {
            /* 애니메이션 이름 | 지속 시간 | 타이밍 함수 | 채우기 모드(끝 상태 유지) */
            animation: fadeIn 1.5s ease-in-out forwards;
        }

        .fade-in-process {
            animation: fadeInProcess 1.0s ease-in-out;
        }
        .fade-out-process {
            animation: fadeOutProcess 1.0s ease-in-out;
        }
        @keyframes fadeInProcess {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform:  translateY(0); }
        }

        @keyframes fadeOutProcess {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform:  translateY(-10px); }
        }

        @keyframes fade-scan {
            0% {
                opacity: 0.1;
            }
            50% {
                opacity:  1;
            }
            100% {
                opacity: 0.1;
            }
        }

        /* 2. 애니메이션 클래스 정의 및 적용 */
        .text-flashing-scan {
            /* keyframes 이름, 지속 시간, 타이밍 함수, 반복 설정 */
            animation: fade-scan 3s ease-in-out infinite;
            /* (옵션) 텍스트가 깜빡일 때 다른 요소에 영향을 주지 않도록 설정 */
            display: inline-block;
        }
        /*
        /* 제목 스타일 */
        .ai-text-response h1 {
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        .ai-text-response h2 {
            font-size: 20px;
            font-weight: bold;
            margin-top : 10px;
        }
        .ai-text-response h3 {
            font-size: 18px;
            margin-top : 10px;
        }
        .ai-text-response h4 {
            font-size: 16px;
            margin-top : 10px;
        }

        /* 굵게 스타일 */
        .ai-text-response strong {
            font-weight: bold;
        }

        /* 목록 스타일 */
        .ai-text-response ul,
        .ai-text-response oll,
        .process-text ul,
        .process-text ol {
            padding-left: 20px;
            margin: 10px 0;
            list-style-type: disc;
        }
        a.report { font-size: 20px; font-weight: bold;  text-decoration: none; background-color: #e0e2fa; padding: 5px; border-radius: 5px; margin: 20px 10px;} 
        a.report:hover { background-color: #9ba2ff; padding: 5px; border-radius: 5px; }
        #send-btn:disabled {
            cursor: not-allowed;
            background-color: #ccc;
        }
        #history-panel { width: 250px; flex-shrink: 0; padding: 20px; overflow-y: auto; background-color: #f8f9fa; }

        table, th, td {
            border: solid 1px #666;
            border-collapse: collapse;
            padding: 8px;
        }
        th { background-color: #ccc;}
        span.process-text {
            line-height: 1.6;
            color: #888;
        }
       
    </style>
</head>
<body class="bg-white">
    
    <div class="flex h-screen bg-gray-100">
        <!-- 채팅 히스토리 영역 -->
        <div id="history-panel" class="w-64 bg-gray-50 border-l border-gray-200 p-4 flex flex-col">
            <h3 class="text-lg font-semibold mb-2">채팅 기록</h3>
            <div class="mb-4">
                <span class="text-blue-600 hover:text-blue-800 font-medium cursor-pointer" onclick="location.reload();">
                    + 새 채팅
                </span>
            </div>
            <ul id="history-list" class="space-y-2 overflow-y-auto flex-1">
                <li class="history-item p-2 rounded-md hover:bg-gray-200 cursor-pointer" data-session-id="657">무선청소기</li>
                <li class="history-item p-2 rounded-md hover:bg-gray-200 cursor-pointer" data-session-id="660">스탠드형에어컨</li>
                <li class="history-item p-2 rounded-md hover:bg-gray-200 cursor-pointer" data-session-id="663">아이폰17과 갤럭시s25의 비교</li>
            </ul>
        </div>
        <!-- 채팅영역 -->
        <div class="flex-1 flex flex-col bg-white">
            <!-- 채팅 컨텐츠 영역 -->
            <div id="message-container" class="flex-1 p-6 space-y-4 overflow-y-auto">
                <div class="flex response-container">
                    <div class="ai-text-response">
                        <p>안녕하세요! 어떤 주제에 대해 분석할까요? 사용자 세그먼트를 추가하거나 분석하고자 하는 상품/카테고리/브랜드명을 입력해주세요.</p>
                        <p>사용자 세그먼트를 2개 이상 추가할 경우 비교분석이 같이 진행됩니다.</p>
                        <p style="font-style: italic; color: #666">(예시) "가습기 시장동향 분석",  "스마트폰 미래전망", "2025년 남성 패션 트렌드"</p>
                    </div>
                </div>
            </div>
            <!-- 사용자 입력 영역 -->
            <div id="user-input-container" class="flex items-center p-4 bg-white border-t border-gray-200">
                <button id="popup-btn" class="ml-4 px-6 py-3 bg-blue-600 text-white rounded-full font-medium shadow-md hover:bg-blue-700 transition-colors" style="margin-left: -10px; margin-right: 10px;" alt="팝업">+</button>
                    <span id="myTooltip" class="info_tooltip_comm_custom mg_lt_10 pointer pos_lt mg_tp_2" title="">
                        <img src="/images/icon_ex_time.png" style="margin-left: -10px;" class="list_icon_info" alt="정보">
                    </span>
                <textarea id="user-input" class="flex-1 resize-none p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all" rows="1" placeholder="메시지를 입력하세요..." oninput="autoResize(this)"></textarea>
                <button id="send-btn" class="ml-4 px-6 py-3 bg-blue-600 text-white rounded-full font-medium shadow-md hover:bg-blue-700 transition-colors">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                </button>
            </div>
            <p style="text-align: center; height: 25px; line-height: 25px; font-size: 14px">LLM도 실수할 수 있습니다. 자동진행 되어야 함에도 불구하고 중간중간 LLM이 사용자 입력 요청할 경우, <b>"네" 또는 "진행해줘"</b>라고 입력해주세요.</p>
        </div>
        
    </div>

    <script type="text/javascript">
        const messageContainer = document.getElementById('message-container'); // 채팅창 전체
        const userInput = document.getElementById('user-input'); // 사용자 입력 텍스트박스
        const sendBtn = document.getElementById('send-btn'); // 사용자 입력 버튼

        // 텍스트 영역 자동 크기 조절
        function autoResize(element) {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        }

        // 사용자 메세지 추가
        function fn_AddMessage_User(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = "flex justify-end";
            
            const contentDiv = document.createElement('div');
            contentDiv.className = "message user-message";
            contentDiv.innerHTML = text;
            
            messageDiv.appendChild(contentDiv);
            messageContainer.appendChild(messageDiv);

            // 사용자 입력 시 최상단으로 이동하면서 이전 컨텐츠 높이 초기화.
            var prev_response_container = messageDiv.previousElementSibling;
            prev_response_container.style.minHeight = 'auto';

            return contentDiv
        }

        // 응답 컨테이너 영역 추가
        function fn_AddContainer_AI() {
            const aiResponseContainer = document.createElement('div');
            aiResponseContainer.className = 'flex flex-col items-start w-full mt-4 response-container relative';
            messageContainer.appendChild(aiResponseContainer);
            
            return aiResponseContainer;
        }

        // 응답 사고영역 추가 : "잠시만 기다려주세요.." 기본값에서 thinking 시 "생각하는 과정" 으로 변경.
        function fn_AddThinkingBlock_AI(aiResponseContainer) {
            const thinkingProcessElement = document.createElement('div');
            thinkingProcessElement.className = 'thinking-process-container w-full mb-2 rounded-xl shadow-sm border border-gray-200';
            
            // 로딩 스피너 및 텍스트 포함
            thinkingProcessElement.innerHTML = `
                <div class="flex items-center justify-between p-4 thinking-bar" onclick="fn_click_thinking_bar(this)">
                    <div class="flex items-center space-x-2">
                        <svg class="loading-spinner w-5 h-5 text-blue-500"  xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span class="text-sm font-medium text-gray-700 thinking-text text-flashing-scan">요청사항을 처리 중입니다... 잠시만 기다려 주세요... (진행상황은 하단에 표시됩니다)</span>
                    </div>
                    <button class="transform transition-transform text-gray-500" style="display: none">
                        <svg class="w-5 h-5 toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="thinking-content">
                </div>
            `;
            aiResponseContainer.appendChild(thinkingProcessElement);

            const div_process_Text = document.createElement("div");
            div_process_Text.className = "process-div absolute left-0 w-full flex items-center justify-center bg-white bg-opacity-95 z-10";
            div_process_Text.style="top: 50px; height: 300px; padding: 1rem"
            div_process_Text.innerHTML = '<span class="text-l font-medium process-text w-full h-full" >잠시만 기다려주세요...</span>';

            aiResponseContainer.appendChild(div_process_Text);

            //thinkingProcessElement.classList.add('expanded');
            fn_move_scrollTop();
            
            return thinkingProcessElement;
        }

        // 응답 텍스트 영역 추가
        function fn_AddResponseBlock_AI(aiResponseContainer) {
            const aiResponseContent = document.createElement('div');
            aiResponseContent.className = 'ai-text-response w-full h-full';
            aiResponseContainer.appendChild(aiResponseContent);

            // 독립 서비스 시 로직
            aiResponseContainer.style.minHeight = window.innerHeight - 200 + "px";

            lst_user_message = document.querySelectorAll('.user-message');
            if ((lst_user_message != null) && (lst_user_message.length > 0)) {
                messageDiv = lst_user_message[lst_user_message.length - 1];
                messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' })
            }
            
            /* 딥애드 배포 시 로직
             // 앞에 답변 답변 내용 길이에 맞춰서 높이 다시 조정
            var lst_response_container = document.querySelectorAll(".response-container");
            if (lst_response_container.length >= 2) {
                lst_response_container[lst_response_container.length - 2].style.minHeight = 'auto';
            }


            // 현재 사용자 채팅에 대한 답변을 화면 전체 표시하기 위해 처리
            aiResponseContainer.style.minHeight = window.innerHeight - 300 + "px";
            fn_move_scrollTop();
            */
            
            return aiResponseContent;
        }

        
        
        // 입력창 활성/비활성화
        function fn_input_disabled(disabled_yn) {
            sendBtn.disabled = disabled_yn;
            userInput.disabled = disabled_yn;
        }

        function fn_move_scrollTop() {
            messageContainer.scrollTop = messageContainer.scrollHeight; // 항상 마지막 메시지가 보이도록 스크롤
        }

        // 사고영역(로딩중) 업데이트
        function fn_updateLoading(thinkingProcessElement, contextText, thinking_yn, complete_yn) {
            // 사고 중 표시 영역을 Thought 값에 따라 사고영역이 있는지 없는지 먼저 체크
            // 사고 영역이 없을 경우 로딩중 표시 후 아예 해당 영역을 삭제
            // 사고 영역이 있을 경우 진행중 => 완료 텍스트 변경
            const spinner = thinkingProcessElement.querySelector('.loading-spinner');
            const thinking_bar = thinkingProcessElement.querySelector('.thinking-bar');
            const thinkingText = thinkingProcessElement.querySelector(".thinking-text ");
            const process_div = thinkingProcessElement.parentNode.querySelector(".process-div");
            const process_Text = process_div.querySelector(".process-text");

            // 작업 완료 시 로딩중 아이콘 삭제
            if (complete_yn) {
                spinner.style.display = 'none'; // 로딩 스피너 숨김
                thinkingText.innerHTML = "✅ 처리 과정(사고 과정) 보기";
                thinking_bar.classList.add("cursor-pointer")
                thinking_bar.style = "display: block"
                thinkingText.classList.remove("text-flashing-scan");
                thinking_bar.attributes["onclick"] = "this.parentNode.classList.toggle('expanded'); this.querySelector('.toggle-icon').classList.toggle('rotate-180');"
                process_Text.innerHTML = "";
                process_div.style = "display: none";

            } else {
                if (thinking_yn) {
                    // 생각하는 과정일 경우 텍스트 변경
                    spinner.style.display = 'block';
                    thinkingText.innerHTML = "요청사항을 처리 중입니다... 잠시만 기다려 주세요... (진행상황은 하단에 표시됩니다)";

                    process_Text.classList.remove("fade-in-process");
                    process_Text.classList.add("fade-out-process");
                    process_Text.classList.remove("fade-out-process");

                    setTimeout(() => {
                            process_Text.classList.add("fade-in-process");
                            process_Text.innerHTML = contextText;
                    }, 500); // fade-out 후 텍스트 교체
                }
            }
        }

        let thinking_yn = false;

        // 메세지 전송 및 요청 처리
        async function requestChat() {
            const input_text = userInput.value.trim();
            if (!input_text) {
                alert("메세지를 입력해주세요");
                return;
            }

            const query = input_text;
        
            /********************** TO DO  : 사용자 계정정보 연동 필요 ************************/
            const userId = "ksson";
            const sessionId = "session_1000285";
            /********************** TO DO  : 사용자 계정정보 연동 필요 ************************/

            // 1. 사용자 메시지 표시
            const userMessageContent = fn_AddMessage_User(input_text);
            userInput.value = '';
            userInput.style.height = 'auto';
            fn_input_disabled(true); // 입력창 비활성화

             // AI 응답을 위한 새로운 컨테이너 생성
            const  aiResponseContainer= fn_AddContainer_AI();

            // '생각하는 과정' 영역 동적 생성 및 표시
            const thinkingProcessElement = fn_AddThinkingBlock_AI(aiResponseContainer);
            thinking_content = thinkingProcessElement.querySelector(".thinking-content");
            
            
            // AI 응답을 위한 텍스트 영역 생성 (초기에는 숨김)
            aiResponseContent = fn_AddResponseBlock_AI(aiResponseContainer);

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: query,
                        user_id: userId,
                        session_id: sessionId
                    })
                });

                if (!response.body) {
                    fn_addMessage('agent', 'root_agent', '스트림을 지원하지 않는 응답입니다.');
                    return;
                }

                const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();

                while (true) {
                    try {
                        const { value, done } = await reader.read();
                        if (done) break;

                        // 결과 JSON응답이 여러건 동시에 올 경우 분할하여 차례로 표시.
                        const jsonRegex = /{".*?"}/gs;
                        const jsonMatches = value.matchAll(jsonRegex);

                        if (jsonMatches == null) {
                            if ((value != null) && (value.length > 0)) {
                                // JSON 형태가 아니지만 텍스트로 응답 결과가 나왔을 경우
                                let json_data = {
                                    "event_type": "message",
                                    "content": value
                                }
                                thinking_yn = true;
                                fn_updateLoading(thinkingProcessElement, contentText, thinking_yn, false);
                                thinking_content.innerHTML += "<p>&nbsp;</p>" + contentText;
                            }
                        } else {

                            for (const match of jsonMatches) {
                                const jsonString = match[0];
                                try {
                                    const data = JSON.parse(jsonString);

                                    let contentText = typeof data.content === 'string' ? data.content : JSON.stringify(data.content);

                                    // 디버깅용 출력
                                    console.log('----------------------------------- event_type: ' + data.event_type + ' -----------------------------------');
                                    console.log(data.content);
                                    console.log('---------------------------------------------------------------------------------------------------------');

                                    if (data.event_type === 'close') {
                                        break;
                                    }
                                    
                                    // 에이전트 명 표시(임시)
                                    contentText = "[" + data.agent_name + "] " + contentText;

                                    if ((data.event_type === 'thinking') || (data.event_type === 'message')) {
                                        thinking_yn = true;
                                        fn_updateLoading(thinkingProcessElement, contentText, thinking_yn, false);
                                        thinking_content.innerHTML += "<p>&nbsp;</p>" + contentText + "<p>&nbsp;</p><hr>";
                                    } else {
                                        fn_updateLoading(thinkingProcessElement, "", thinking_yn, true);
                                        span_fianl_response = document.createElement("span");
                                        span_fianl_response.className = "final_response";
                                        aiResponseContent.appendChild(span_fianl_response);

                                        span_fianl_response.innerHTML = contentText;
                                        span_fianl_response.classList.remove("fade-in-effect");
                                        setTimeout(() => {
                                            span_fianl_response.classList.add("fade-in-effect");
                                        }, 50);
                                        
                                    }
                                } catch (e) {
                                    console.error("JSON 파싱 오류:" +  e.message + "\n원본 문자열:" + jsonString);
                                    continue;
                                }
                            }
                        }

                    } catch (e) {
                        console.error("오류발생:" + e.message);
                        if (e.message == 'network error') {
                            break;
                        } else {                            
                            continue;
                        }
                    }
                }
                
            } catch (e) {
                console.error('요청 실패:', e.message);
                aiResponseContent.innerHTML += "분석 중 오류가 발생했습니다. 계속 진행하실려면 '계속 진행해줘'  또는 '방금 작업 진행한 부분 다시 진행해줘' 라고 입력해주세요.";
            } finally {
                fn_updateLoading(thinkingProcessElement, "", thinking_yn, true);
                fn_input_disabled(false);
                userInput.focus();
            }
        }

       function fn_click_thinking_bar(thinking_bar) {
            if (thinking_bar.classList.contains("cursor-pointer")) {
                thinking_bar.parentNode.classList.toggle('expanded'); 
                thinking_bar.querySelector('.toggle-icon').classList.toggle('rotate-180');
            }
       } 

        // 전송 버튼 클릭 및 Enter 키 입력
        sendBtn.addEventListener('click', requestChat);
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                requestChat();
            }
        });
    </script>
</body>
</html>
